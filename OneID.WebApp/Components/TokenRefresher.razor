@inject IHttpClientFactory HttpClientFactory
@inject ILogger<TokenRefresher> Logger
@inject NavigationManager Navigation

@code {
    private PeriodicTimer? _timer;
    private readonly TimeSpan _checkInterval = TimeSpan.FromMinutes(4);
    private CancellationTokenSource _cts = new();

    protected override void OnInitialized()
    {
        Logger.LogInformation("TokenRefresher iniciado. Verificando validade do token a cada {Interval}...", _checkInterval);

        _timer = new PeriodicTimer(_checkInterval);

        _ = Task.Run(async () =>
        {
            while (await _timer.WaitForNextTickAsync(_cts.Token))
            {
                try
                {
                    await InvokeAsync(async () => await CheckAndRefreshTokenAsync());
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Erro inesperado ao renovar token.");
                }
            }
        }, _cts.Token);
    }

    private async Task CheckAndRefreshTokenAsync()
    {
        try
        {
            var client = HttpClientFactory.CreateClient();
            var response = await client.PostAsync("https://localhost:7200/v1/auth/refresh-token", null, _cts.Token);

            if (response.IsSuccessStatusCode)
            {
                Logger.LogInformation("Token renovado automaticamente com sucesso.");
            }
            else
            {
                Logger.LogWarning("Falha ao renovar token automaticamente. Redirecionando...");
                Navigation.NavigateTo("/request-token", forceLoad: true);
            }
        }
        catch (TaskCanceledException)
        {
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Erro ao tentar renovar o token automaticamente.");
            Navigation.NavigateTo("/request-token", forceLoad: true);
        }
    }

    public void Dispose()
    {
        _cts.Cancel();
        _timer?.Dispose();
        _cts.Dispose();
    }
}
